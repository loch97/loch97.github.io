<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="loch97">



    <meta name="description" content="just record life">



<title>Cpp_learningnote3 | loch&#39;s blog</title>



    <link rel="icon" href="/su_loch.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">loch&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/some_webs/COUNT_DOWN.html">CountDown</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">loch&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/some_webs/COUNT_DOWN.html">CountDown</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Cpp_learningnote3</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">loch97</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 17, 2021&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>[toc]</p>
<p>reference：《黑马》C++系列教程 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ClaireSy/article/details/108422945">基础</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/ClaireSy/article/details/108423047">核心</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/ClaireSy/article/details/108423061">提高</a></p>
<blockquote>
<p>本篇主要参考提高篇进行记录</p>
</blockquote>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p>模板就是建立通用的模具，提高复用性。模板只是一个框架，不能直接使用</p>
</li>
<li><p><strong>函数模板</strong></p>
<ul>
<li>C++另一种编程思想称为 <strong>泛型编程</strong>，主要利用的技术就是模板</li>
<li>C++提供两种模板机制：函数模板 和 类模板</li>
</ul>
</li>
</ul>
<p>函数模板语法：<code>template&lt;typename T&gt;</code>，其中typename可以用class代替</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">Swap</span>(a, b);<span class="comment">//1.自动类型推导</span></span><br><span class="line">	<span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(a, b);<span class="comment">//2.显示指定类型</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*tips：</p>
<ol>
<li><p>自动类型推导，必须推导出<strong>一致的数据类型T</strong>才可以使用</p>
</li>
<li><p>显示指定类型，必须<strong>确定出T的数据类型</strong>才可以使用</p>
</li>
</ol>
<p>也就是说，凡是给出了模板定义，之后跟着的函数，必须给出数据类型才能调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//函数中没用用到模板类型T，但是调用时必须给出才能使用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>普通函数与函数模板的区别</li>
</ul>
<ol>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用的时候，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显式指定类型的方式，可以发生隐式类型转换</li>
</ol>
<ul>
<li>普通函数与函数模板的调用规则</li>
</ul>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板  <code>funtion&lt;&gt;(a, b);</code></li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配（例如不用进行隐式转换），优先调用函数模板</li>
</ol>
<ul>
<li>模板的局限性：传入数组、类对象、自定义数据类型等数据不能处理，可以为这些特定的类型提供具体化的模板</li>
</ul>
<p>具体化的模板以<code>template&lt;&gt;</code>开头，通过名称来指出类型，具体化优先于常规模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Person&amp; p1, Person&amp; p2)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>类模板</strong></li>
</ul>
<p>建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1， <span class="keyword">typename</span> T2, ...&gt;</span><br><span class="line"><span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类模板与函数模板的区别</li>
</ul>
<ol>
<li>类模板<strong>没有自动类型推导</strong>的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数（在显示指定的时候可以更换参数类型，如int-&gt;double）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nametype</span>, <span class="keyword">class</span> <span class="title class_">agetype</span> = <span class="type">int</span>&gt;<span class="comment">//2.defualt parameter</span></span><br><span class="line"><span class="keyword">class</span> Person&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">	Person &lt;string, <span class="type">double</span>&gt;<span class="built_in">p</span>(<span class="string">&#x27;string&#x27;</span>,<span class="number">10</span>);<span class="comment">//1.显示指定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类模板中的成员函数并不是一开始就创建的，在调用的时候才会创建</li>
<li>类模板对象做函数参数</li>
</ul>
<ol>
<li>指定传入的类型 – 直接显示对象的数据类型</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>参数模板化 – 将对象中的参数变为模板进行传递</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>整个类模板化 – 将这个对象类型模板化进行传递</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类模板与继承</li>
</ul>
<ol>
<li>当子类继承的父类是一个类模板时，子类在声明的时候要制定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活制定出父类中T的类型，子类也需要变为类模板</li>
</ol>
<ul>
<li>类模板成员函数类外实现</li>
<li>类模板份文件编写</li>
<li>类模板与友元</li>
</ul>
<h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><blockquote>
<p>STL(Standard Template Library, 标准模板库)</p>
</blockquote>
<p>STL广义上分为：**容器(container)、算法(algorithm)和迭代器(iterator)**。其中容器和算法之间通过迭代器进行无缝连接。STL中几乎所有的代码都采用了模板类或者模板函数。</p>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set和map等，用来存放数据；</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等；</li>
<li>迭代器：扮演了容器与算法之间的胶合剂；</li>
<li>仿函数：行为类似函数，可以作为算法的某种策略；</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西；</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<ul>
<li>STL中容器、算法、迭代器</li>
</ul>
<ol>
<li>容器将运用最广泛的一些数据结构实现出来，分为序列式容器和关联式容器两种：</li>
</ol>
<p>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置。</p>
<p>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<ol start="2">
<li>算法分为质变算法和非质变算法：</li>
</ol>
<p>质变算法：是指运算过程中会更改区间内的元素内容，如拷贝、替换、删除等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，如查找、计数、遍历、寻找极值等</p>
<ol start="3">
<li>迭代器：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。每个容器都有自己专属的迭代器（类似于指针）</li>
</ol>
<h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><ol>
<li>vector存放内置数据类型</li>
</ol>
<hr>
<p>容器：<code>vector</code></p>
<p>算法：<code>for_each</code></p>
<p>迭代器：<code>vector&lt;int&gt;::iterator</code></p>
<hr>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 遍历方式1</span></span><br><span class="line">    <span class="keyword">while</span>(pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">        pBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历方式2</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历方式3</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Myprint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>vector存放自定义数据类型</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age)&#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; (*it).mName &lt;&lt;<span class="string">&quot;, Age: &quot;</span> &lt;&lt; (*it).mAge &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person*&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        Person* p = (*it);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p-&gt;mName &lt;&lt;<span class="string">&quot;, Age: &quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>vector容器嵌套容器</li>
</ol>
<blockquote>
<p>容器中嵌套容器，将所有数据遍历输出</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    </span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt;&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt;&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin != pEnd) &#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = pBegin-&gt;<span class="built_in">begin</span>(); vit != pBegin-&gt;<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">        pBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STL-常用容器"><a href="#STL-常用容器" class="headerlink" title="STL - 常用容器"></a>STL - 常用容器</h2><h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><ul>
<li>string是c++风格的字符串，本质上是一个类</li>
</ul>
<p>string与char *的区别：char*是一个指针，string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</p>
<ul>
<li>string构造函数</li>
</ul>
<p><code>string()</code>&#x2F;&#x2F; 创建一个空的字符串</p>
<p><code>string(const char* s)</code>&#x2F;&#x2F; 使用字符串s初始化</p>
<p><code>string(const string&amp; str)</code>&#x2F;&#x2F; 使用一个string对象初始化另一个string对象</p>
<p><code>string(int n, char c)</code>&#x2F;&#x2F; 使用n个字符c初始化</p>
<ul>
<li>string赋值操作</li>
</ul>
<p><code>string&amp; operator=(const char* s);</code> &#x2F;&#x2F;char*类型字符串赋值给当前的字符串</p>
<p><code>string&amp; operator=(const string &amp;s);</code> &#x2F;&#x2F;把字符串s赋给当前的字符串</p>
<p><code>string&amp; operator=(char c);</code> &#x2F;&#x2F;字符赋值给当前的字符串</p>
<p><code>string&amp; assign(const char *s);</code> &#x2F;&#x2F;把字符串s赋给当前的字符串</p>
<p><code>string&amp; assign(const char *s, int n);</code> &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</p>
<p><code>string&amp; assign(const string &amp;s);</code> &#x2F;&#x2F;把字符串s赋给当前字符串</p>
<p><code>string&amp; assign(int n, char c);</code> &#x2F;&#x2F;用n个字符c赋给当前字符串</p>
<ul>
<li>string字符串拼接</li>
</ul>
<blockquote>
<p>实现在字符串末尾拼接字符串</p>
</blockquote>
<p><code>string&amp; operator+=(const char* str);</code> &#x2F;&#x2F;重载+&#x3D;操作符</p>
<p><code>string&amp; operator+=(const char c);</code> &#x2F;&#x2F;重载+&#x3D;操作符</p>
<p><code>string&amp; operator+=(const string&amp; str);</code> &#x2F;&#x2F;重载+&#x3D;操作符</p>
<p><code>string&amp; append(const char *s);</code> &#x2F;&#x2F;把字符串s连接到当前字符串结尾</p>
<p><code>string&amp; append(const char *s, int n);</code> &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</p>
<p><code>string&amp; append(const string &amp;s);</code> &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</p>
<p><code>string&amp; append(const string &amp;s, int pos, int n);</code>&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</p>
<ul>
<li>string查找和替换</li>
</ul>
<blockquote>
<p>查找：查找指定字符串是否存在</p>
<p>替换：在指定的位置替换字符</p>
</blockquote>
<p><code>int find(const string&amp; str, int pos = 0) const;</code> &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</p>
<p><code>int find(const char* s, int pos = 0) const;</code> &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</p>
<p><code>int find(const char* s, int pos, int n) const;</code> &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</p>
<p><code>int find(const char c, int pos = 0) const;</code> &#x2F;&#x2F;查找字符c第一次出现位置</p>
<p><code>int rfind(const string&amp; str, int pos = npos) const;</code> &#x2F;&#x2F;查找str最后一次位置,从pos开始查找</p>
<p><code>int rfind(const char* s, int pos = npos) const;</code> &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</p>
<p><code>int rfind(const char* s, int pos, int n) const;</code> &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</p>
<p><code>int rfind(const char c, int pos = 0) const;</code> &#x2F;&#x2F;查找字符c最后一次出现位置</p>
<p><code>string&amp; replace(int pos, int n, const string&amp; str);</code> &#x2F;&#x2F;替换从pos开始n个字符为字符串str</p>
<p><code>string&amp; replace(int pos, int n,const char* s);</code> &#x2F;&#x2F;替换从pos开始的n个字符为字符串s</p>
<blockquote>
<p>conclusion：find查找是从左向右，rfind自右向左；find找不到时返回-1；replace要指定从哪个位置起，多少个字符，替换的字符串。</p>
</blockquote>
<ul>
<li>string字符串比较</li>
</ul>
<blockquote>
<p>字符串按字符的ASCII码进行对比，&#x3D;返回0、&gt;返回1、&lt;返回-1</p>
</blockquote>
<p><code>int compare(const string &amp;s) const;</code> &#x2F;&#x2F;与字符串s比较</p>
<p><code>int compare(const char *s) const;</code> &#x2F;&#x2F;与字符串s比较</p>
<ul>
<li>string字符串存取</li>
</ul>
<p>string中单个字符存取方式有两种</p>
<p><code>char&amp; operator[](int n);</code> &#x2F;&#x2F;通过[]方式取字符</p>
<p><code>char&amp; at(int n);</code> &#x2F;&#x2F;通过at方法获取字符</p>
<ul>
<li>string插入和删除</li>
</ul>
<p><code>string&amp; insert(int pos, const char* s);</code> &#x2F;&#x2F;插入字符串</p>
<p><code>string&amp; insert(int pos, const string&amp; str);</code> &#x2F;&#x2F;插入字符串</p>
<p><code>string&amp; insert(int pos, int n, char c);</code> &#x2F;&#x2F;在指定位置插入n个字符c</p>
<p><code>string&amp; erase(int pos, int n = npos);</code> &#x2F;&#x2F;删除从Pos开始的n个字符</p>
<ul>
<li>string子串</li>
</ul>
<blockquote>
<p>从字符串中获取想要的子串</p>
</blockquote>
<p><code>string substr(int pos = 0, int n = npos) const;</code> &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</p>
<h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><blockquote>
<p>vector数据结构和数组非常相似，也称为单端数组；不同之处在于数组是静态空间，而vector可以动态扩展。这里的动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，将原数据copy新空间，释放原空间。</p>
</blockquote>
<ul>
<li>vector构造函数</li>
</ul>
<p><code>vector&lt;T&gt; v;</code> &#x2F;&#x2F;采用模板实现类实现，默认构造函数</p>
<p><code>vector(v.begin(), v.end());</code> &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</p>
<p><code>vector(n, elem);</code> &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p><code>vector(const vector &amp;vec);</code> &#x2F;&#x2F;拷贝构造函数。</p>
<ul>
<li>vector赋值操作</li>
</ul>
<p><code>vector&amp; operator=(const vector &amp;vec);</code>&#x2F;&#x2F;重载等号操作符</p>
<p><code>assign(beg, end);</code> &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p><code>assign(n, elem);</code> &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<ul>
<li>vector容量和大小</li>
</ul>
<p><code>empty();</code> &#x2F;&#x2F;判断容器是否为空</p>
<p><code>capacity();</code> &#x2F;&#x2F;容器的容量</p>
<p><code>size();</code> &#x2F;&#x2F;返回容器中元素的个数</p>
<p><code>resize(int num);</code> &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p><code>resize(int num, elem);</code> &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</p>
<ul>
<li>vector插入和删除</li>
</ul>
<p><code>push_back(ele);</code> &#x2F;&#x2F;尾部插入元素ele</p>
<p><code>pop_back();</code> &#x2F;&#x2F;删除<strong>最后一个元素</strong></p>
<p><code>insert(const_iterator pos, ele);</code> &#x2F;&#x2F;迭代器指向位置pos插入元素ele</p>
<p><code>insert(const_iterator pos, int count,ele);</code>&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</p>
<p><code>erase(const_iterator pos);</code> &#x2F;&#x2F;删除迭代器指向的元素</p>
<p><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</p>
<p><code>clear();</code> &#x2F;&#x2F;删除容器中所有元素</p>
<ul>
<li>vector数据存取（除了用迭代去获取vector容器中元素，[]和at也可以）</li>
</ul>
<p><code>at(int idx);</code> &#x2F;&#x2F;返回索引idx所指的数据</p>
<p><code>operator[];</code> &#x2F;&#x2F;返回索引idx所指的数据</p>
<p><code>front();</code> &#x2F;&#x2F;返回容器中第一个数据元素</p>
<p><code>back();</code> &#x2F;&#x2F;返回容器中最后一个数据元素</p>
<ul>
<li>vector互换容器</li>
</ul>
<p><code>swap(vec);</code> &#x2F;&#x2F; 将vec与本身的元素互换</p>
<ul>
<li>vector预留空间</li>
</ul>
<blockquote>
<p>减少vector在动态扩展容量时的扩展次数</p>
</blockquote>
<p><code>reserve(int len);</code> &#x2F;&#x2F; 容器预留len个元素长度，预留位置不初始化，元素不可访问</p>
<h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><blockquote>
<p>双端数组，可以对头端进行插入和删除操作。</p>
</blockquote>
<p>deque与vector区别：</p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度比vector块</li>
<li>vector访问元素时的速度比deque快</li>
</ul>
<p>deque内部工作原理：</p>
<p>​		deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据。中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间。deque容器的迭代器也是支持随机访问的。</p>
<h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><blockquote>
<p>stack是一种先进后出（FILO）的数据结构，它只有一个出口。</p>
</blockquote>
<p>栈中只有顶端的元素才可以被外界使用，不允许有遍历行为。有push和pop操作。</p>
<ul>
<li>stack常用接口</li>
</ul>
<p>入栈 — push</p>
<p>出栈 — pop</p>
<p>返回栈顶 — top</p>
<p>判断栈是否为空 — empty</p>
<p>返回栈大小 — size</p>
<h3 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h3><blockquote>
<p>queue是一种FIFO的数据结构，有两个出口。</p>
</blockquote>
<p>队列容器允许从一端新增元素，从另一端移除元素，只有队头和队尾才可以被使用，不允许有遍历行为。</p>
<ul>
<li>queue常用接口</li>
</ul>
<p>入队 — push</p>
<p>出队 — pop</p>
<p>返回队头元素 — front</p>
<p>返回队尾元素 — back</p>
<p>判断队是否为空 — empty</p>
<p>返回队列大小 — size</p>
<h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><blockquote>
<p>list（链表）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的，list将数据进行链式储存。</p>
</blockquote>
<p>STL中的链表是一个双向循环链表，list的迭代器只支持前移和后移，属于双向迭代器。</p>
<p>list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<blockquote>
<p>tips: const_iterator和iterator都可以遍历容器的元素，并访问这些元素的值。iterator可以改变元素值，但是const_iterator不可改。</p>
</blockquote>
<ul>
<li>list 插入与删除</li>
</ul>
<p>尾插 — push_back</p>
<p>尾删 — pop_back</p>
<p>头插 — push_front</p>
<p>头删 — pop_front</p>
<p>插入 — insert</p>
<p>删除 — erase</p>
<p>移除 — remove</p>
<p>清空 — clear</p>
<ul>
<li>list反转和排序</li>
</ul>
<p>反转 — reverse</p>
<p>排序 — sort （成员函数）</p>
<h3 id="set-x2F-multiset容器"><a href="#set-x2F-multiset容器" class="headerlink" title="set&#x2F;multiset容器"></a>set&#x2F;multiset容器</h3><blockquote>
<p>所有元素都会在插入时自动被排序</p>
</blockquote>
<p>本质：set&#x2F;multiset属于关联式容器。底层结构是用二叉树实现的。</p>
<ul>
<li>set与multiset区别：set不允许容器中有重复元素，multiset允许容器中有重复元素。</li>
</ul>
<p>set不可以插入重复数据，而multiset可以</p>
<p>set插入数据的同时会返回插入结果，表示插入是否成功</p>
<p>multiset不会检测数据，因此可以插入重复数据</p>
<ul>
<li>set构造与赋值</li>
</ul>
<p>set容器插入数据时用insert</p>
<p>set容器插入数据的数据会自动排序</p>
<ul>
<li>set大小和交换</li>
</ul>
<p>统计大小 — size</p>
<p>判断是否为空 — empty</p>
<p>交换容器 — swap</p>
<ul>
<li>set查找和统计</li>
</ul>
<p>查找 — find （返回的是迭代器）</p>
<p>统计 — count （对于set，结果为0或者1）</p>
<ul>
<li>pair对组创建</li>
</ul>
<blockquote>
<p>成对出现的数据，利用对组可以返回两个数据</p>
</blockquote>
<p><code>pair&lt;type, type&gt; p ( value1, value2 );</code></p>
<p><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></p>
<p><code>pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);</code># 注意insert()的返回是一个pair对组，此外对pair对组的访问通过<code>pair.first or pair.second</code>进行。</p>
<ul>
<li>set容器排序</li>
</ul>
<blockquote>
<p>set容器默认排序规则为从小到大，利用仿函数，可以改变排序规则。</p>
<p>仿函数 (functor)，就是<strong>使一个类的使用看上去像一个函数</strong>。 其实现就是类中实现一个 operator ()，这个类就有了类似函数的行为，就是一个仿函数类了。</p>
</blockquote>
<p>通过定义结构体(或类)，并在其中重载()运算符，来自定义排序函数。然后，在定义set的时候，将结构体加入其中例如如下代码中的set&lt;int, intComp&gt;和set&lt;string, strComp &gt;。</p>
<h3 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h3><blockquote>
<p>map中所有元素都是pair，pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值），所有元素都会根据元素的key自动排序。</p>
</blockquote>
<p>本质：map&#x2F;multimap属于关联式容器，底层结构用二叉树实现。</p>
<ul>
<li>map和multimap的区别：map不允许容器中有重复的key，而multimap可以</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>loch97</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/c/"># c++</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/03/17/Cpp-learning-note-2/">Cpp_learningnote2</a>
            
            
            <a class="next" rel="next" href="/2021/03/17/Makefile/">makefile</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© loch97 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
